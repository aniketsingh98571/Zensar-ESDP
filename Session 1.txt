select * from employees;
select * from countries;
select country_id||country_name from countries;
--Session 2
--Lesson 3:-Using Single row functions to customeise output
--Objectives:-
--Types of SQL Functions:-
1.Single Row Functions ---Returns one result per row
2. Multiple Row Functions --Return one result per set of rows

--Single Row Functions:-
1.Manipulate data items
2.Accept arguments and returns one value
3.Act on each row that is returned
4.Return one result per row.
5.May modify the data type
6.Can be nested
7.Accept arguments that can be a column or expression
function_name[(arg1,arg2,...)]

--Character Functions:
--Case Manipulation Functions  -Lower,upper,INITCAP
SELECT LOWER('SQL COURSE') FROM DUAL;
SELECT UPPER('SQL COURSE') FROM DUAL;
SELECT INITCAP('SQL COURSE')  FROM DUAL;

---CHARACTER MANIPULATION FUNCTIONS --CONCAT,SUBSTRA,LENGTH,INSTR,LPAD,RPAD
SELECT CONCAT('HELLO','WORLD') FROM DUAL;
SELECT CONCAT(EMPLOYEE_ID,FIRST_NAME) FROM EMPLOYEES ORDER BY EMPLOYEE_ID;
SELECT LENGTH('HELLOWORLD') FROM DUAL;
SELECT INSTR('HELLOWORLD','W') FROM DUAL;
SELECT INSTR('ANIKET','T') FROM DUAL --GIVES THE POSITION OF PARTICUALAR CHARACTER
SELECT LPAD(25000,10,'*') FROM DUAL; --COUNTS THE  NO OF CHARACTERS TO THE LEFT AND ADD THE SPECIFIED CHARACTER N TIMES
SELECT RPAD(25000,10,'*') FROM DUAL  --10 IS FOR SELECTING NO OF CHARACTERS.
SELECT REPLACE('JACK AND JUE','J','BL') FROM DUAL;
SELECT TRIM('H' FROM 'HELLOWORLD') FROM DUAL;

SELECT EMPLOYEE_ID, CONCAT(FIRST_NAME,LAST_NAME) NAME, JOB_ID,LENGTH(LAST_NAME),INSTR(LAST_NAME,'A') 
"CONTAINS 'A'?" FROM EMPLOYEES;

--NUMBER FUNCTIONS
1.ROUND-ROUNDS VALUE TO SPECIFIED DECIMAL
2.TRUNC-TRUNCAE VALUE TO SPECIFIED DECIMAL
3.MOD-RETURNS REMAINDER OF DIVISION

SELECT ROUND(45.926,2) FROM DUAL; --after decimal 2 position
SELECT TRUNC(45.926,0) FROM DUAL; 
SELECT TRUNC(TO_DATE('27-OCT-92','DD-MON-YY'), 'YEAR')
  "New Year" FROM DUAL;
SELECT MOD(1600,400) FROM DUAL;

SELECT SYSDATE FROM DUAL;
SELECT * FROM NLS_SESSION_PARAMETERS; //DATE FORMAT

--CURRENT DATE FORMAT
SELECT SYSDATE FROM DUAL;
SELECT * FROM EMPLOYEES WHERE HIRE_DATE='17-06-03';

--ORACLE SESSION PARAMETER
SELECT * FROM NLS_SESSION_PARAMETERS; //DATE FORMAT
--ALTER ORACLE SESSION PARAMETER
ALTER SESSION SET NLS_DATE_FORMAT='YY-MON-DD';
--VERIFY THE ALTER RESULT IN THE SYSTEM DATE FORMAT
SELECT SYSDATE FROM DUAL;

--WORKING WITH DATES
1.THE ORACLE DATABASE STORES DATES IN AN INTERNAL NUMERIC FORMAT;
CENTURY, YEAR, MONTH, DAY, HOURS, MINUTES AND SECONDS
2.THE DEFAULT DATE DISPLAY FORMAT IS DD-MM-YY

SELECT LAST_NAME, (SYSDATE-HIRE_DATE)/7 FROM EMPLOYEES ;

SELECT ROUND(SYSDATE-TO_DATE('17-04-01','DD-MM-YY')) FROM DUAL;

DATE FUNCTIONS:-
MONTHS_BETWEEN -NUMBER OF  MONTHS BETWEEN TWO DATES
ADD_MONTHS- ADD CALENDAR MONTHS TO DATE
NEXT_DAY-NEXT DAY OF THE DATE SPECIFIED
LAST_DAY-LAST DAY OF THE MONTH
ROUND-ROUND DATE
TRUNC-TRUNCATE DATE

SELECT MONTHS_BETWEEN('95-FEB-06','94-AUG-11') FROM DUAL;
SELECT ADD_MONTHS('11-JAN-94',6) FROM DUAL;
SELECT NEXT_DAY('01-SEP-95','FRIDAY') FROM DUAL;
SELECT LAST_DAY('01-FEB-95') FROM DUAL;

-- Elements of the Date Format Model
YYYY  -> Full year in numbers
YEAR  -> Year spelled out (in English)
MM    -> Two-digit value for month
MONTH -> Full name of the month
MON   -> Three-letter abbreviation of the month
DY    -> Three-letter abbreviation of the day of the week
DAY   -> Full name of the day of the week
DD    -> Numeric day of the month

--NVL FUNCTION
SELECT LAST_NAME, SALARY,COMMISSION_PCT,(SALARY+NVL(COMMISSION_PCT,0)) FROM EMPLOYEES;


--NULLIF
SELECT NULLIF(COMMISSION_PCT,SALARY) FROM EMPLOYEES;
SELECT * FROM EMPLOYEES;
SELECT NULLIF(EMPLOYEE_ID,MANAGER_ID),NULLIF(MANAGER_ID,DEPARTMENT_ID) FROM EMPLOYEES;
 
 --CASE EXPRESSION
SELECT last_name, job_id, salary,
    CASE job_id WHEN 'IT_PROG' THEN 1.10*salary
        WHEN 'ST_CLERK' THEN 1.15*salary
        WHEN 'SA_REP' THEN 1.20*salary
        ELSE salary END "REVISED_SALARY"
FROM employees;
 
 --LESSON 4 REPORTING AGGREGATED DATE USING GROUP FUNCTIONS
 --GROUP FUNCTIONS:
 GROUP FUNCTIONS OPERATE ON SETS OF ROWS TO GIVE ONE RESULT PER GROUP
 
 --TYPES OF GROUP FUNCTIONS
 1.AVG
 2.COUNT
 3.MAX
 4.MIN
 5.STDDEV
 6.SUM
 7.VARIANCE
 
 SELECT [COLUMN, ] GROUP_FUNCTION(COLUMN),..
 FROM TABLE
 (WHERE CONDITION)
 (GROUP BY COLUMN)
 (ORDER BY COLUMN)
 ORDER OF SQL QUERIES IS IMPORTANT
 SELECT * FROM EMPLOYEES
 SELECT COUNT(COMMISSION_PCT) FROM EMPLOYEES; ---COUNT IGNORES NULL VALUES
 
 SELECT SUM(SALARY) AS SUM, MIN(SALARY) AS MIN, MAX(SALARY) AS MAX FROM EMPLOYEES;
 SELECT MIN(HIRE_DATE),MAX(HIRE_DATE) FROM EMPLOYEES;
 SELECT COUNT(*) FROM EMPLOYEES;
 --COUNT FUNCTION IGNORES NULL VALUES
 
 --DISTINCT
 SELECT DISTINCT DEPARTMENT_ID FROM EMPLOYEES;
 SELECT COUNT(DISTINCT DEPARTMENT_ID) FROM EMPLOYEES;
 
 --GROUP FUNCTION AND NULL VALUES
 --GROUP FUNCTION IGNORE NULL VALUES IN THE COLUMN
 SELECT AVG(COMMISSION_PCT) FROM EMPLOYEES;
 
 --THE NVL FUNCTION FORCES GROUP FUNCTION TO INCLUDE NULL VALUES;
 --USING THE GROUP BY CLAUSE
 --ALL COLUMNS IN THE SELECT LIST  THAT ARE NOT IN GROUP FUNCTIONS MUST BE IN THE GROUP BY CLAUSE
 SELECT DEPARTMENT_ID,COUNT(SALARY),MIN(SALARY),MAX(SALARY),AVG(SALARY) FROM EMPLOYEES GROUP BY DEPARTMENT_ID;
 
 --THE GROUP BY COLUMN DOES NOT HAVE TO BE IN THE SELECT LIST.
 SELECT COUNT(SALARY),MIN(SALARY),MAX(SALARY),AVG(SALARY)
 FROM EMPLOYEES GROUP BY DEPARTMENT_ID;
 
 --USING THE GROUP BY CLAUSE ON MULTIPLE COLUMNS
 SELECT DEPARTMENT_ID,JOB_ID,COUNT(SALARY),MIN(SALARY),MAX(SALARY) FRO EMPLOYEES
 GROUP BY DEPARTMNET_ID,JOB-ID
 ORDER BY DEPARTMENT_ID;
 
 --ILLEGAL QUERIES
 1.YOU CANNOT USE THE WHERE CLAUSE TO RESTRICT GROUPS.
 2.YOU USE THE HAVING CLAUSE TO RESTRICT CHANGES
 3.YOU CANNOT USE GROUP FUNCTIONS IN THE WHERE CLAUSE.
 SELECT * FROM EMPLOYEES HAVING SUM(SALARY)>10000
 SELECT DEPARTMENT_ID,AVG(SALARY) FROM EMPLOYEES WHERE AVG(SALARY)>8000
 GROUP BY DEPARTMNETN_ID ---GROUP FUNCTIONS NOT ALLOWED
 
 --RESTRICTING GROUP RESULTS WITH THE HAVING CLAUSE.
 WHEN YOU USE THE HAVING CLAUSE, THE ORACLE SERVER RESTRICTS GROUPS AS FOLLOWS
 1.ROWS ARE FETCHED
 2.THE GROUP FUNCTIONS 
 
 SELECT DEPARTMENT_ID,COUNT(SALARY),MIN(SALARY),AVG(SALARY)
 FROM EMPLOYEES
 GROUP BY DEPARTMENT_ID
 
 SELECT DEPARTMNET_ID,COUNT(SALARY),MIN(SALARY) FROM EMPLOYEES WHEE DEPARTMENT_ID IS NOT NULL
 
 SELECT JOB_ID,COUNT(SALARY),MIN(SALARY),MAX(SALARY)
 FROM EMPLOYEES
 GROUP BY JOB_ID
 
 SELECT JOBID,COUNT(SALARY),MIN(SALARY) FROM EMPLOYEES WHERE JOBID IS NOT LIKE '%rep%'
 GROUP BY JOBID
 
 SELECT JOBID,COUNT(SALRY),MIN(SALARY),MAX(SLAARY)
 FROM EMPLOYESS WHERE JOBID NOT LIKE '%REP%'
 GROUP BY JOBID
 HAVING MAX(SALARY)>15000
 
 --THIS ORDER MUST BE FOLLOWED
 SELECT COLUMN,GROUP_FUNCTION
 FROM TABLE
 WHERE CONDITION
 GROUP BY CLAUSE
 HAVING
 ORDER BY
 
 --NESTING GROUP FUNCTIONS
 
 --LESSON 5 DISPLAYING DATA FROM MULTIPLE TABLES
 SELECT * FROM REGIONS; --PRIMARY KEY:REGION_ID
 SELECT * FROM COUNTRIES;  --PRIMARY KEY:REGION_ID
 SELECT * FROM LOCATIONS    --PRIMARYKEY:LOCATION_ID, FOREIGNKRY:COUNTRY_ID
 SELECT * FROM DEPARTMENTS --PRIMARY:DEPARTMENT_ID, FOREIGNKEY:MANAGER_ID,LOCATION_ID
 SELECT * FROM EMPLOYEES -PRIMARYKEY:EMPLOYEE_ID, FOREIGNKEY:DEPARTMENT_ID.
 SELECT * FROM JOBS: --PRIMARYKEY:JOB_ID
 SELECT * FROM JOB_HISTORY; PRIMARYKEY:-EMPLOYEE_ID
 SELECT REGIONS.REGION_NAME,COUNTRIES.COUNTRY_NAME FROM REGIONS,COUNTRIES ;
 SELECT REGION_NAME, REGION_ID FROM REGIONS NATURAL JOIN
 SELECT COUNTRY_NAME FROM COUNTRIES ;
 
 --TYPES OF JOINS
 --SCENARIO1 NATURAL JOIN HAVING ONE COMMON KEY
 SELECT COUNTRYID,COUNTRYNAME,REGIONNANME
 FROM COUNTRIES
 NATURAL JOIN REGIONS
 --ON COUNTRIES.EGIONID==REGIONS.REGIONID
 
 SCENARIO2--NATURAL JON HAIVNG TWO COMMON KEY
 SELECT EMPLOYEEID.,FIRSTNAME,LSTNAME,DEPARTMENT NAME
 FROM EMPLOYEES
 NATURAL JOIN DEPARTMENTS
 
 USING CLAUSES
 SELECT EMPLOYEEIDFIRSTNAME,STNAME,DEPARTMENT
 FROM EMPLOYEES JOIN DEPARTMENTS USING DEPARTMNETS
 USING(DEPARTMENT ID)
   
   --INNER OIN
   SELECT EMPLOYEE_ID,FIRST_NAME,LAST_NAME,DEPARTMENT_NAME,CITY,COUNTRY_NAME,REGION_NAME
   FROM EMPLOYEES INNER JOIN DEPARTMENTS,REGIONS ON
  DEPARTMENTS.DEPARTMENT_ID=EMPLOYEES.DEPARTMENT_ID
 SELECT INSTR('HELLOWORLD','O') FROM DUAL;
 SELECT * FROM EMPLOYEES;
 SELECT UPPER(FIRST_NAME) FROM EMPLOYEES WHERE DEPARTMENT_ID=100; --Single row function because it returns query results for each row

 SELECT COUNT(EMPLOYEE_ID) FROM EMPLOYEES; --MULTIPLE ROW FUNCTION BECAUSE IT RETURNS ONE RESULT FOR ALL SET OF ROWS.
 
 SELECT COUNTRY_NAME,REGION_ID,LOCATION_ID,POSTAL_CODE FROM COUNTRIES NATURAL JOIN LOCATIONS; --NATURAL JOIN --WORKS IF THE TWO TABLES HAS ATLEAST ONE COMMON COLUMN WITH SAME NAME AND DATATYPE BETWEEN THEM.

 SELECT COUNTRY_NAME,REGION_ID,LOCATION_ID,POSTAL_CODE FROM COUNTRIES NATURAL JOIN LOCATIONS WHERE REGION_ID=1; --NATURAL JOIN USING WHERE CLAUSE FOR SPECIFIC DATA

SELECT location_id, postal_code, country_name
    FROM locations
    JOIN countries
    USING (country_id);  --NATURAL JOIN USING "USING CLAUSE"[EQUIJOIN]
 SELECT D.DEPARTMENT_NAME,D.MANAGER_ID,E.FIRST_NAME,E.SALARY FROM DEPARTMENTS D JOIN EMPLOYEES E USING(D.DEPARTMENT_ID)
 
 SELECT D.DEPARTMENT_NAME,E.FIRST_NAME FROM DEPARTMENTS D INNER JOIN EMPLOYEES E ON D.DEPARTMENT_ID=E.DEPARTMENT_ID --INNER JOIN-FOR WORKING WITH 2 OR MORE TABLES USING COMMON COLUMNS
 
 SELECT D.DEPARTMENT_NAME,J.START_DATE,E.FIRST_NAME FROM ((DEPARTMENTS D INNER JOIN EMPLOYEES E ON D.DEPARTMENT_ID=E.DEPARTMENT_ID) INNER JOIN JOB_HISTORY J ON D.DEPARTMENT_ID=J.DEPARTMENT_ID) --WORKING WITH THREE TABLES UISNG INNER JOIN
 
 SELECT E.EMPLOYEE_ID,E.FIRST_NAME,E.LAST_NAME,D.DEPARTMENT_NAME,L.CITY,C.COUNTRY_NAME,R.REGION_NAME FROM EMPLOYEES E INNER JOIN DEPARTMENTS D ON E.DEPARTMENT_ID=D.DEPARTMENT_ID INNER JOIN LOCATIONS L ON L.LOCATION_ID=D.LOCATION_ID 
 INNER JOIN COUNTRIES C ON C.COUNTRY_ID=L.COUNTRY_ID INNER JOIN REGIONS R ON C.REGION_ID=R.REGION_ID; --WORKING WITH 4 TABLES UISNG 'ON' CLAUSE
 
 --SESSION 3
 --QUALIFYING AMBIGOUS COLUMN NAMES
 1.USE TABLE PREFIXES TO QUALIFY COLUMN NAMES THAT ARE IN MULTIPLE TBALES.
 2.USE TABLE PREFIXES TO IMPROVE PERFORMANCE
 3.USE COLUMN ALIASES TO DISTINGUISH COLUMNS THAT HAVE IDENTICAL NAMES BUT REDSIDE IN DIFFERENT TABLES
 4
 DO NOT USE ALISASES ON COLUMN THAT ARE IDENTIFIED IN THE USING CLAUSE AND LISTED ELSSE WHERE ON THE
 SQL STATEMENT
 
 --USING TABLE ALISASES
 1.USE TBALE ALISASES TO SIMPLYIFY QUERIES
 2.USE TBALE ALISASE TO IMPROVE PERFORMANCE
 
 SELECT EMPLOYEE_ID,FIRST_NAME,LAST_NAME,DPARTMENT_ID,DEPARTMENT_NAME
 FROM EMPLOYEES JOIN DEPARTMENTS ON EMPLOYEES,DEPARTMENT_ID=DEPARTMENTS.DEPARTMENT_ID;
 --ERROR:AMBIGUITY DUE TO DEPARTMENT_ID MENTIONED IN SLECT STATEMENT
 
 --ALISING ONLY THE AMBIGUOUS COLUMN
 SELECT EMPLOYEE_ID,FIRST_NAME,LAST_NAME,DEPARTMENT_NAME,DEPARTMENTS.DEPARTMNET_ID 
 FROM EMPLOYEES JOIN
  DEPARTMNETS
  ON EMPLOYEES.DEPARTMENT_ID=DEPARTMENTS.DEPARTMENT_ID
  
  --ALIASING ALL THE AMBIGOUS COLUMN
  SELECT E.EMPLOYEE_ID,E.FIRST_NAME,E.LAST_NAME,D.DEPARTMENT_ID,D.DEPARTMENT_NAME FROM 
  EMPLOYEES E
  JOIN DEPARTMENTS D
  ON E.DEPARTMENT_ID=D.DEPARTMENT_ID;
  
  --DO NOT USE ALISASES ON CLOUMNS THAT ARE IDENTIFIED IN THE USING CLAUSE AND  LISTED ELSE WHERE
  --IN THE SQL STATEMENT
  
  SELECT E.EMPLOYEE_ID,E.FIRST_NAME,E.LAST_NAME,D.DEPARTMENT_ID,D.DEPARTMENT_NAME
  FROM EMPLOYEES E JOIN DEPARTMENT D
  USING (DEPARTMENT_ID)